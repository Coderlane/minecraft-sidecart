package firebase

import (
	"bufio"
	"context"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"os"
	"sync"

	"golang.org/x/oauth2"
	gauth "golang.org/x/oauth2/google"

	"github.com/Coderlane/minecraft-sidecart/firebase/internal"
)

// AuthProvider is an enumeration of supported authentication providers.
type AuthProvider int

const (
	// GoogleAuthProvider provides support for authenticating with Google
	GoogleAuthProvider AuthProvider = iota
)

var authProviderConfigs = map[AuthProvider][]byte{}

// UserCache provides an interface for caching authenticated users and their
// `RefreshToken`. You should avoid backing this with insecure storage like a
// plaintext file.
type UserCache interface {
	// Get fetches a user from the cache. If no user is found, nil is returned
	// with a nil error. If a failure occurs an error is returned.
	Get(string) (*User, error)
	// Set sets a user in the cache.
	Set(string, *User) error
	// Delete deletes a user from the cache.
	Delete(string)
}

const (
	// DefaultUser represents the default user to be loaded and stored in the
	// `UserCache`.
	DefaultUser = "default"
)

// MemoryUserCache implements the `UserCache` interface with an in-memory map.
type MemoryUserCache map[string]*User

// Get fetches a user from the cache.
func (muc MemoryUserCache) Get(userID string) (*User, error) {
	user, ok := muc[userID]
	if !ok {
		return nil, nil
	}
	return user, nil
}

// Set sets a user in the cache.
func (muc *MemoryUserCache) Set(userID string, user *User) error {
	(*muc)[userID] = user
	return nil
}

// Delete deletes a user from the cache.
func (muc *MemoryUserCache) Delete(userID string) {
	delete(*muc, userID)
}

// Auth handles authenticating users
type Auth struct {
	app          *App
	emulatorHost string
	idpConfig    *internal.IdpConfig
	userCache    UserCache

	mtx         sync.RWMutex
	currentUser *User
	token       *oauth2.Token
}

// User contains details of a user from Firebase
type User struct {
	UserID        string `json:"userId"`
	EmailVerified bool   `json:"emailVerified"`
	Email         string `json:"email"`
	DisplayName   string `json:"displayName"`
	PhotoURL      string `json:"photoUrl"`
	RefreshToken  string `json:"refreshToken"`
}

// CurrentUser returns the current authenticated user or nil if no user is
// authenticated.
func (auth *Auth) CurrentUser() *User {
	auth.mtx.RLock()
	user := auth.currentUser
	auth.mtx.RUnlock()
	return user
}

// SignInWithConsole authenticates the current user by outputting an
// authentication URL to stdout. The user should copy that URL in to their
// browser and paste the authentication code back in to the command line.
func (auth *Auth) SignInWithConsole(
	ctx context.Context, cfg *oauth2.Config) (*User, *oauth2.Token, error) {
	return auth.SignInWithConsoleWithIO(ctx, cfg, os.Stdin, os.Stdout)
}

// SignInWithConsoleWithIO performs the same operation as SignInWithConsole,
// but allows for specifying an input `reader` and output `writer.
func (auth *Auth) SignInWithConsoleWithIO(
	ctx context.Context, cfg *oauth2.Config,
	reader io.Reader, writer io.Writer) (*User, *oauth2.Token, error) {
	// Force OOB auth for console auth
	tmpCfg := *cfg
	tmpCfg.RedirectURL = "urn:ietf:wg:oauth:2.0:oob"
	state, err := createRandomState()
	if err != nil {
		return nil, nil, err
	}
	url := tmpCfg.AuthCodeURL(state, oauth2.AccessTypeOffline)
	fmt.Fprintf(writer, "Visit this url to authenticate: %v\n", url)
	fmt.Fprintf(writer, "Input code: ")
	tokenReader := bufio.NewReader(reader)
	var code string
	_, err = fmt.Fscanf(tokenReader, "%s", &code)
	if err != nil {
		return nil, nil, err
	}
	token, err := tmpCfg.Exchange(ctx, code)
	if err != nil {
		return nil, nil, err
	}
	return auth.SignInWithToken(ctx, token)
}

// SignInWithToken takes an auth token generated by firebase and exchanges it
// for a refresh token and a user.
func (auth *Auth) SignInWithToken(
	ctx context.Context, token *oauth2.Token) (*User, *oauth2.Token, error) {
	user, token, err := auth.idpConfig.Exchange(ctx, token)
	if err != nil {
		return nil, nil, err
	}

	auth.mtx.Lock()
	auth.currentUser = &User{
		UserID:        user.LocalID,
		EmailVerified: user.EmailVerified,
		Email:         user.Email,
		DisplayName:   user.DisplayName,
		PhotoURL:      user.PhotoURL,
		RefreshToken:  token.RefreshToken,
	}
	err = auth.userCache.Set(DefaultUser, auth.currentUser)
	auth.mtx.Unlock()
	return auth.currentUser, token, err
}

func (auth *Auth) signInWithUser(ctx context.Context,
	user *User) (token *oauth2.Token, err error) {
	token, err = auth.idpConfig.Refresh(ctx,
		&oauth2.Token{RefreshToken: user.RefreshToken})
	if err != nil {
		return nil, err
	}
	auth.currentUser = user
	auth.currentUser.RefreshToken = token.RefreshToken
	auth.token = token
	err = auth.userCache.Set(DefaultUser, auth.currentUser)
	return token, err
}

// SignInWithUser authenticates with a firebase user with a refresh token.
func (auth *Auth) SignInWithUser(ctx context.Context,
	user *User) (token *oauth2.Token, err error) {
	auth.mtx.Lock()
	token, err = auth.signInWithUser(ctx, user)
	auth.mtx.Unlock()
	return token, err
}

// SignOut deletes the current user from the cache and then resets the current
// user and token.
func (auth *Auth) SignOut() {
	auth.mtx.Lock()
	if auth.currentUser != nil {
		auth.userCache.Delete(auth.currentUser.UserID)
	}
	auth.currentUser = nil
	auth.token = nil
	auth.mtx.Unlock()
}

// Token implements the TokenSource interface by providing authenticated
// tokens for the current user.
func (auth *Auth) Token() (token *oauth2.Token, err error) {
	auth.mtx.RLock()
	if auth.token.Valid() {
		token = auth.token
	} else if auth.currentUser == nil {
		err = fmt.Errorf("no user is currently authenticated")
	}
	auth.mtx.RUnlock()
	if token != nil || err != nil {
		return token, err
	}
	auth.mtx.Lock()
	defer auth.mtx.Unlock()
	if auth.token.Valid() {
		token = auth.token
		return token, nil
	}
	// TODO: Get the context from elsewhere
	ctx := context.Background()
	return auth.signInWithUser(ctx, auth.currentUser)
}

func createRandomState() (string, error) {
	b := make([]byte, 16)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	encoded := base64.URLEncoding.EncodeToString(b)
	return encoded, nil
}

// NewOAuthConfig creates a new `oauth.Config` for the provided `AuthProvider`
// based on the built in auth provider configs.
func NewOAuthConfig(provider AuthProvider) *oauth2.Config {
	cfg, err := gauth.ConfigFromJSON(authProviderConfigs[provider], "")
	if err != nil {
		panic(err)
	}
	switch provider {
	case GoogleAuthProvider:
		cfg.Scopes = []string{
			"https://www.googleapis.com/auth/userinfo.email",
			"https://www.googleapis.com/auth/userinfo.profile",
			"openid",
		}
	}
	return cfg
}
